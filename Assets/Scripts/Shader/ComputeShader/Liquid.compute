#include "Utils.hlsl"
#pragma kernel CSMain

RWTexture2D<float4> Result;
RWTexture2D<float4> Environment;
int seed;

bool isLiquid(uint kind)
{
    return kind==WATER
        ||kind==OIL
        ||kind==ACID
        ||kind==MAGMA
        ||kind==F_FIRE_SOURCE;
}

bool canMove(uint2 id,uint mKind)
{
    uint kind=float2int(Result[id].x);
    return (kind==EMPTY
            ||kind==OIL
            ||kind==EMPTY
            ||kind==ACID
            ||kind==WATER)
            &&kind!=mKind;
}

void moveLeft(uint3 id,uint kind)
{
    if(checkKind(left_2(id),kind)||checkKind(leftUp(id),kind))
        return;
    setZ(id.xy,DIR_LEFT);
    move(id.xy,left(id));
}

void moveRight(uint3 id,uint kind)
{
    if(checkKind(right_2(id),kind)||checkKind(rightUp(id),kind))
        return;
    setZ(id.xy,DIR_RIGHT);
    move(id.xy,right(id));
}

/**
 * \brief 
 * \param id 位置ID
 * \param kind 流体种类
 * \param viscosity 流体粘稠度（1最大，0最小）
 */
void updateLiquid(uint3 id,uint kind,float viscosity)
{
    float4 ori=Result[id.xy];
    
    //重力
    if(isAir(Result[down(id)]))
    {
        setZ(id.xy,DIR_KEEP);
    }
    else if(rand(id,seed)<viscosity)
    {
        bool l1=canMove(left(id),kind);
        bool r1=canMove(right(id),kind);
        bool l2=canMove(left_2(id),kind);
        bool r2=canMove(right_2(id),kind);

        if(l1&&r1)
        {
            if(l2&&!r2)
                moveLeft(id,kind);
            else if(r2&&!l2)
                moveRight(id,kind);
            else
            {
                uint dir=float2int(ori.z);
                bool mLeft=dir==DIR_KEEP?rand(id,seed)<0.5f:dir==DIR_LEFT;

                if(mLeft)
                    moveLeft(id,kind);
                else
                    moveRight(id,kind);
            }
        }
        else if(l1)
            moveLeft(id,kind);
        else if(r1)
            moveRight(id,kind);
        else
            setZ(id.xy,DIR_KEEP);
    }
}

void updateOil(uint3 id)
{
    uint kind1=float2int(Result[left(id)].x);
    uint kind2=float2int(Result[right(id)].x);
    uint kind3=float2int(Result[down(id)].x);
    uint kind4=float2int(Result[up(id)].x);

    bool nearFire=kind1==FIRE||kind2==FIRE||kind3==FIRE||kind4==FIRE;
    bool nearFireSource=kind1==FIRE_SOURCE||kind2==FIRE_SOURCE||kind3==FIRE_SOURCE||kind4==FIRE_SOURCE;
    bool nearAir=kind1==EMPTY||kind2==EMPTY||kind3==EMPTY||kind4==EMPTY;
    uint temp=float2int(Environment[id.xy].x);
    
    if(nearAir&&(nearFireSource||nearFire||temp>=25))
    {
        setKind(id.xy,F_FIRE_SOURCE);
        setY(id.xy,40);
    }
}

float getViscosity(uint kind)
{
    switch (kind)
    {
    case WATER:
        return 1;
    case OIL:
        return 0.7f;
    case ACID:
        return 1;
    case MAGMA:
        return 0.3f;
    default:
        return 1;
    }
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint kind=float2int(Result[id.xy].x);
    float viscosity=getViscosity(kind);
    
    if(isLiquid(kind))
        updateLiquid(id,kind,viscosity);
    if(checkKind(id.xy,OIL))
        updateOil(id);
}

void setTemperature(uint2 id,float value)
{
    float4 ori=Environment[id.xy];
    Environment[id.xy]=float4(value,ori.yzw);
}

bool checkKind(uint2 id,uint kind)
{
    return float2int(Result[id.xy].x)==kind;
}

void move(uint2 id,uint2 nbrId)
{
    float temp=Result[id.xy].x;
    Result[id.xy]=float4(Result[nbrId].x,Result[id.xy].yzw);
    Result[nbrId]=float4(temp.x,Result[nbrId].yzw);
}

void setKind(uint2 id,uint kind)
{
    float4 ori=Result[id.xy];
    Result[id.xy]=float4(int2float(kind),ori.yzw);
}

void setY(uint2 id,uint value)
{
    float4 ori=Result[id.xy];
    Result[id.xy]=float4(ori.x,int2float(value),ori.zw);
}

void setZ(uint2 id,uint value)
{
    float4 ori=Result[id.xy];
    Result[id.xy]=float4(ori.x,ori.y,int2float(value),ori.w);
}

void setW(uint2 id,uint value)
{
    float4 ori=Result[id.xy];
    Result[id.xy]=float4(ori.x,ori.y,ori.z,int2float(value));
}
